{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/perils-of-premature-optimization/","result":{"data":{"asciidoc":{"html":"<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Throughout my career I&#8217;ve always heard colleagues talk of premature optimization being a bad thing.\nThere have been many blogs on the topic, like this one,\nover the years as well.\nYet, I&#8217;d not had a situation where I&#8217;d written optimized code\nwhich later came back to bite me.</p>\n</div>\n<div class=\"paragraph\">\n<p>In this post I will talk about such a situation from earlier this year.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_the_original_optimized_code\">The Original Optimized Code</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Late last year I was working with a colleague adding custom instrumentation for the\n<a href=\"https://github.com/open-telemetry/opentelemetry-java-instrumentation\" target=\"_blank\" rel=\"noopener\">OpenTelemetry Java agent</a>.\nWe were extending the upstream AWS SDK v2 instrumentation to also capture the payload\nof a HTTP request or response.\nTo not impact user code,\nsuch as modifying the class types being returned from the Apache HTTP Client,\nwe instrument <code>SessionInputBufferImpl</code> directly.\nTo capture input as it&#8217;s read from the socket the <code>fillBuffer</code> method is instrumented on method exit.</p>\n</div>\n<div class=\"paragraph\">\n<p>At this point in processing the socket content,\nthe HTTP headers are still present on the socket&#8217;s <code>InputStream</code>.\nAs such,\nwe need to find the point at which the HTTP headers end and the payload body commences.\nThe separation is found when we find two consecutive sets of <code>\\r\\n</code> characters.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here is the original code to loop through the contents of <code>byte[]</code> in <code>fillBuffer</code>,\nfinding the starting point of the payload:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">int bodyStartPos = -1;\nfor (int i = 0;\n    // We check only if we have at least two characters left, otherwise there is not\n    // enough data in the buffer to contain an HTTP body anyhow.\n    i &lt; len - 1;\n// We manually increment the position in the loop, as increments could be by\n// one or by two depending on what we find.\n) {\n\n  if ((char) buffer[i] != '\\r') {\n    if ((char) buffer[i + 1] == '\\r') {\n      // The first character is not '\\r', but the second is, and we will check\n      // in the next iteration from there.\n      i += 1;\n    } else {\n      // Neither the next nor the following character are '\\r', we can skip both\n      i += 2;\n    }\n  } else if ((char) buffer[i + 2] != '\\r') {\n    // The first character is an '\\r', but the character two positions further is not,\n    // so we likely found the beginning of the next header\n    i += 3;\n  } else if ((char) buffer[i + 1] == '\\n' &amp;&amp; (char) buffer[i + 3] == '\\n') {\n    // We found the end of the headers segment\n    bodyStartPos = i + 4;\n    break;\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>As we knew the structure of the characters we should see on the <code>InputStream</code> of the socket,\nwe worked to minimize the number of iterations in the loop that would need to be performed.\nAt the time we focused on writing efficient code,\nby removing unnecessary iterations.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_what_was_the_problem\">What was the Problem?</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Early this year I was contacted by a customer seeing CPU utilization spike to <em>100%</em> on all cores!\nAs I&#8217;d not seen this from my own testing with the java agent,\nI was curious as to what was happening.</p>\n</div>\n<div class=\"paragraph\">\n<p>They described a service where it would start fine,\nbut after running for about 5 minutes the CPU utilization would spike and never abate.\nThe CPU spike would result in a request taking 20 to 30 seconds to complete,\ninstead of less than 5 seconds.\nThere was nothing obvious I could think of causing the spike,\nso it would require more detailed investigation.</p>\n</div>\n<div class=\"paragraph\">\n<p>The team running the service were not the developers,\nrequiring a different approach to understand and replicate the problem.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_the_investigation\">The Investigation</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>I first wanted to determine how to reproduce the issue,\nenabling me to experiment in my local environment and not in the customers.\nI found a distributed trace exhibiting the high response time,\nand the service graph had a service writing to an S3 bucket.</p>\n</div>\n<div class=\"paragraph\">\n<p>I had the first clue!\nNext was to determine which instrumentation was being used at the time.\nWriting to S3 meant it was most likely using AWS SDK instrumentation,\nbut it could have been either v1 or v2.\nDigging into the OpenTelemetry span data I found the <code>instrumentationScope</code>\nwas our custom AWS SDK v2 instrumentation.</p>\n</div>\n<div class=\"paragraph\">\n<p>Now I knew where it was going wrong,\nbut I didn&#8217;t have much information on why.</p>\n</div>\n<div class=\"paragraph\">\n<p>I worked with the customer to capture profiling data when the CPU spikes.\nWe used <a href=\"https://www.oracle.com/java/technologies/jdk-mission-control.html\">JDK Mission Control</a>\nto capture recordings with <em>Java Flight Recorder (JFR)</em>.\nAnalyzing the recordings we saw the <code>SessionInputBufferImpl</code> class was taking up\nabout 98% of all memory used by the service.\nThis was definitely an abnormal situation.</p>\n</div>\n<div class=\"paragraph\">\n<p>With all the above information in hand I created a reproducer to upload arbitrary\ndata as a PDF to an S3 bucket.\nRunning the reproducer didn&#8217;t initially trigger the CPU spike.\nI modified the process to spawn 20 threads,\nwith each thread uploading content to an S3 bucket 50 times before exiting.\nRunning the reproducer again,\nI saw the CPU spike after about 30 seconds of execution.</p>\n</div>\n<div class=\"paragraph\">\n<p>With a means to verify whether the issue was resolved,\nI began investigating the instrumentation code.</p>\n</div>\n<div class=\"paragraph\">\n<p>To narrow down where the issue lay,\nI brute forced it.\nI would comment out a part of the custom instrumentation,\nrebuild the java agent,\nand re-run the reproducer.\nIf the CPU still spiked,\nthat piece of code wasn&#8217;t the issue.\nAfter going through all the instrumentation,\nI was down to the for loop shown earlier.\nCommenting out the for loop meant the CPU didn&#8217;t spike!</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_de_optimized_code\">De-optimized Code</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>I spent time evaluating the checks in the loop to see if improvements could be made.\nAfter a while,\nI did see a way to simplify the number of checks in the loop,\nbut it iterates over every character in the <code>byte[]</code>.\nI initially thought it would not be a good solution,\nbut as I didn&#8217;t have any other leads I figured it was worth a shot.</p>\n</div>\n<div class=\"paragraph\">\n<p>Much to my surprise,\nI no longer saw any CPU spikes in the reproducer.\nAnd memory usage of the <code>SessionInputBufferImpl</code> class dropped to almost nothing.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s the revised for loop:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">int bodyStartPos = -1;\nfor (int i = 0;\n    // We check only if we have at least four characters left, otherwise there is not\n    // enough data in the buffer to contain an HTTP body anyhow.\n    i &lt; len - 3;\n    i++\n) {\n\n  if ((char) buffer[i] == '\\r' &amp;&amp; (char) buffer[i + 1] == '\\n'\n    &amp;&amp; (char) buffer[i + 2] == '\\r' &amp;&amp; (char) buffer[i + 3] == '\\n') {\n\n    // We found the end of the headers segment :-)\n    bodyStartPos = i + 4;\n    break;\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_lesson_learned\">Lesson Learned</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>When writing the initial code I had naively thought less iterations would be faster.\nI failed to take into account the complexity of the checks within the loop.\nClearly this is a case of being too clever for our own good when writing the code.</p>\n</div>\n<div class=\"paragraph\">\n<p>This taught me an invaluable lesson.\nDon&#8217;t optimize code unless you know there is a performance issue.\nIf your instincts lead you down the wrong optimization path,\nthe situation could end up being far worse than a simpler implementation.</p>\n</div>\n</div>\n</div>","document":{"title":"The Perils of Premature Optimization"},"fields":{"slug":"/blog/perils-of-premature-optimization/"},"pageAttributes":{"title":null,"description":null,"date":"June 09, 2024"}}},"pageContext":{"slug":"/blog/perils-of-premature-optimization/"}},"staticQueryHashes":["1000148989","19992949","764694655","78439061"],"slicesMap":{}}